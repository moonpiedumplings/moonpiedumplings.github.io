<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-02-15">

<title>Jeffrey Fonseca – A comparision of hypervisors/platforms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Jeffrey Fonseca</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../projects/index.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../playground/index.html"> 
<span class="menu-text">Playground</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../guides/index.html"> 
<span class="menu-text">Guides</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../talks/index.html"> 
<span class="menu-text">Talks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../writeups/index.html"> 
<span class="menu-text">Writeups</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/moonpiedumplings"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#intro" id="toc-intro" class="nav-link active" data-scroll-target="#intro">Intro</a></li>
  <li><a href="#desktop-vs-hci-vs-selfhosted-cloud" id="toc-desktop-vs-hci-vs-selfhosted-cloud" class="nav-link" data-scroll-target="#desktop-vs-hci-vs-selfhosted-cloud">Desktop vs HCI vs (Selfhosted) Cloud</a></li>
  <li><a href="#desktop-hypervisors-comparison" id="toc-desktop-hypervisors-comparison" class="nav-link" data-scroll-target="#desktop-hypervisors-comparison">Desktop Hypervisors comparison</a></li>
  <li><a href="#hciclouds" id="toc-hciclouds" class="nav-link" data-scroll-target="#hciclouds">HCI/Clouds</a></li>
  <li><a href="#appliance-vs-hackable-hypervisor-platforms" id="toc-appliance-vs-hackable-hypervisor-platforms" class="nav-link" data-scroll-target="#appliance-vs-hackable-hypervisor-platforms">“Appliance” vs “Hackable” hypervisor platforms</a>
  <ul>
  <li><a href="#automatibility" id="toc-automatibility" class="nav-link" data-scroll-target="#automatibility">Automatibility</a></li>
  </ul></li>
  <li><a href="#performance" id="toc-performance" class="nav-link" data-scroll-target="#performance">Performance</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">A comparision of hypervisors/platforms</h1>
  <div class="quarto-categories">
    <div class="quarto-category">linux</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 15, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Currently incomplete, this won’t render in the blog posts part until it is complete.</p>
<section id="intro" class="level1">
<h1>Intro</h1>
<p>Virtualization is an extremely important part of modern server infrastructure, in addition to virtual machine’s other uses as a test bed, portable environments, or even a gaming host.</p>
<p>Naturally, there exist a myriad of ways to virtualize, many platforms with different purposes, features, prices (time is a cost as well), and so on.</p>
<p><a href="https://en.wikipedia.org/wiki/Comparison_of_platform_virtualization_software">Wikipedia has a comparison of “platform virtualization,”</a> which is brief overview of every almost every type of virtualization, including the management platforms, including containers/container platforms and other <a href="https://en.wikipedia.org/wiki/OS-level_virtualization">operating system level virtualization</a></p>
<p>I won’t cover everything, because it’s a <strong>lot</strong>, but I’ve tried out many of the relevant virtual machine managers and I thought I would share my thoughts on the one’s I have experience with, most of which are the more popular options out there.</p>
<p>I was also prompted to do so by the changes to VMware’s liscensing, so I’ve heard many people are searching for alternatives. However, this article still uses ESXi as an example, to compare to other platforms like vSphere or non VMware products.</p>
</section>
<section id="desktop-vs-hci-vs-selfhosted-cloud" class="level1">
<h1>Desktop vs HCI vs (Selfhosted) Cloud</h1>
<p>VMWare desktop literally has <em>desktop</em> in the name, making it’s usecase pretty clear. Desktop virtualization platforms are things like VMWare Desktop, or VirtualBox which are aimed at your single computer seeking to emulate one or more machines.</p>
<p>One difference between desktop hypervisors and the other options, is that VMWare and VirtualBox are <a href="https://en.wikipedia.org/wiki/Hypervisor#Classification">type 2 hypervisors</a>. This means that they will perform significantly worse than type 1 hyperviors, and in general, your “desktop” hypervisors sacrifice performance for convience.</p>
<p>There also exists libvirt + virt-manager, or hyper-v as a desktop hypervisor, which are type 1 hypervisors, but they aren’t as popular.</p>
<p><a href="https://en.wikipedia.org/wiki/Hyper-converged_infrastructure">Hyperconverged infrastructure</a> (HCI) is the modern server management paradigm where, rather than having multiple servers, each dedicated to something (firewall, storage, compute, etc), every machine plays every role. This is done by converting servers into a virtualization cluster, where resources such as compute, storage, and network interfaces can be pooled and shared across machines.</p>
<p>A common example of HCI I see is, rather than having a physical firewall, a firewall OS will be installed on a virtual machine, and the network layout will be entirely virtual, with connections done between virtual machines. I’ve seen this setup on esxi/vsphere or proxmox.</p>
<p><a href="https://en.wikipedia.org/wiki/Cloud_computing">Cloud computing</a>, according to the Wikipedia definition, is the instant access to resources, in a multi user system. It has different <a href="https://en.wikipedia.org/wiki/Cloud_computing#Deployment_models">deployment models</a>, but I will be focusing on self hosted private/public clouds in this article, and referring to them as “selfhosted clouds”.</p>
<p>In practice, I find that what seperates a self hosted cloud from an HCI platform is multi-tenancy (multiple users or organizations), and automatibility. A public/private cloud should be set up in a way that users can request resources, within limits (to prevent a single user from DOS-ing your cloud by asking for all resources), and also the ability for those users to automate provisioning resources (i.e.&nbsp;creating virtual machines), or setting up those resources (i.e.&nbsp;configuring virtual machines).</p>
<p>Although not every HCI is a selfhosted cloud, every selfhosted cloud is an HCI platform.</p>
<p>Of course, this line is very blurry. Technically, VMware vSphere supports multi-tenancy, and can be automated… but for some reason it doesn’t seem to be a popular choice for a private cloud (probably the price). Rather than a binary, it would be better to look at it like a spectrum, where on one end is things like openstack, which is like your own personal AWS, even able to do things like databases as a service, and on the other end there is VMware ESXI, where the automation is locked behind the price of vSphere.</p>
</section>
<section id="desktop-hypervisors-comparison" class="level1">
<h1>Desktop Hypervisors comparison</h1>
<p>Here’s a list:</p>
<ul>
<li>Virt-manager (libvirt)</li>
<li>VMware Player (or Workstation)</li>
<li>VirtualBox</li>
<li>Hyper-V</li>
</ul>
<p>“Why don’t you use Virt-Manager?” I asked a Fedora Linux user, who was using VMware workstation as a desktop hypervisor.</p>
<p>The reason: software defined networking. Only VMware Workstation (or player?) gives you the ability to create somewhat complex networking configurations from a grpahical interface, like having a firewall virtual machine be the entry point to a network. Although possible, if you have a good understanding of Linux networking and the Linux command line, convinience is often a reason why people choose one product over another.</p>
<p><a href="https://www.VirtualBox.org/manual/ch06.html">VirtualBox’s networking</a> on Linux is also lacking. There is no way to have what you can have with VMware (both) or Libvirt, where you have a virtual network and your host has full access to that virtual network. Rather, with VirtualBox, you’re 3 options are:</p>
<ul>
<li>Forward ports from guest to host</li>
<li>Host-Only networking: add a second adapter in addition to the original virtual ethernet, which can interface with the host.</li>
<li>Bridged networking: Virtual machine connects to the same network the host is connected to, on ethernet this works fine, but on wireless</li>
</ul>
<p>But, VirtualBox is not without it’s advantages. <a href="https://en.wikipedia.org/wiki/Vagrant_(software)">Vagrant</a> is a software to automatically create and provision virtual machines. They selected VirtualBox as their main provider (virtual machine plaform) because it was cross platform and free, compared to other options. The <a href="https://developer.hashicorp.com/vagrant/docs/providers/default">official docs for the default provider</a> mention this.</p>
<p>Most <a href="https://app.vagrantup.com/boxes/search">vagrant boxes</a> are distributed at least as a VirtualBox machine, often only via VirtualBox. Vagrant supports other providers, but VirtualBox is overwhelmingly the most popular one.</p>
<p>Vagrant isn’t the only case of this, however. For some reason, Nixos, a Linux based operating system distributes a <a href="https://nixos.org/download#nixos-virtualbox">VirtualBox demo machine</a>, but not one for any other platform, which always struck me as odd, considering that the popular, most supported choice of hypervisor on Linux is qemu-kvm.</p>
<p>And that brings me to the the final desktop hypervisor I have personally used: qemu-kvm and frontends.</p>
<p>In particular, I usually use libvirt, a daemon which manages qemu-kvm.</p>
<p>I use virt-manager, which is a GUI frontend to libvirt. the core benefit of libvirt as opposed to alternatives, is performance.</p>
<p>KVM is a type 1 hypervisor, as opposed to VMware Workstation/Player, or VirtualBox, which are both type 2. Type 1 hypervisors</p>
</section>
<section id="hciclouds" class="level1">
<h1>HCI/Clouds</h1>
<p>These are roughly ordered from less private cloud features, to a fully featured private cloud. This doesn’t include everything, just what I’ve looked at/worked with.</p>
<ul>
<li>VMware ESXi</li>
<li>Proxmox</li>
<li>LXD</li>
<li>OpenSuse Harvester</li>
<li>XCP-NG + Xen Orchestra</li>
<li>VMware vSphere</li>
<li>Openstack</li>
</ul>
<p>This is a non exhaustive list.</p>
</section>
<section id="appliance-vs-hackable-hypervisor-platforms" class="level1">
<h1>“Appliance” vs “Hackable” hypervisor platforms</h1>
<p>In a <a href="https://www.reddit.com/r/homelab/comments/12j0rry/my_personal_impressions_on_proxmox_vs_xcpng/">reddit post</a>, they compared proxmox and xcp-ng, and one criticism that they had of xcp was that it wasn’t “hackable”.</p>
<p>For some context, desktop/consumer oriented Nvidia GPU’s are often artifically restriced from the ability to divide the GPU up among virtual machines, instead, you can only do all or nothing passthrough.</p>
<p>But with some custom drivers, and software hacks, it’s possible to unlock “virtual gpu” (vGPU), and split the GPU among multiple virtual machines.</p>
<p>Proxmox, being just Debian Linux under the hood is very easy to modify, and vGPU is one popular hack people do.</p>
<p>A developer/advocate for xcp-ng replied saying that <a href="https://www.reddit.com/r/homelab/comments/12j0rry/my_personal_impressions_on_proxmox_vs_xcpng/jfyygkx/">xcp-ng is not meant to be modified, but rather an “appliance”</a></p>
<p>This is a crucial concept in software overall, the difference between something that “just works” and something you can modify.</p>
<p>I had a similar issue with xcp-ng, where I wanted to create a cluster out of many x86_64 Mac Mini’s, but the Linux kernel did not have their wifi drivers. I had a lot of trouble installing wifi drivers, since they weren’t even packaged for the RHEL that xcp-ng uses under the hood, and it was very painful to even find that that XCP-NG was RHEL based, since that wasn’t documented anywhere.</p>
<p>Appliance type softwares are what “just works”. VMWare ESXi/vSphere are more on the appliance side, although there don’t seem to be as many complains about it being too simple.</p>
<p>On the opposite end, is openstack. Openstack is often criticized for being not a HCI platform, but rather a kludge of python code, tying together other forms of virtualized compute (libvirt, vSphere) or virtualized networking. Openstack is not one piece, but rather many components, like compute and networking are seperate components. There do exist platforms which automate the install, like <a href="https://docs.openstack.org/kolla-ansible/latest/">kolla-ansible</a>, which uses ansible to deploy the openstack components to docker containers, but openstack still encounters some of the same problems caused by it’s <em>hackability</em>. Openstack is far from an appliance, a “just works” application, which makes it unsuited for every usecase.</p>
<p>For an organization seeking to do openstack, what I’ve seen is they’ll have a full-time team of engineers, equipped to make changes to openstack’s python base, or low if need be. Although a team of engineers may not be worth it, openstack enables a single team of engineers to manage 100,000+ machines, which can be highly cost effective.</p>
<section id="automatibility" class="level2">
<h2 class="anchored" data-anchor-id="automatibility">Automatibility</h2>
<p>How easy is it to automatically create virtual machines? Is there any way to automatically configure virtual machines?</p>
<p>These questions are important to users of these platforms. Typically, automation is done through some kind of API, which is accessed remotely by tools like Terraform.</p>
<p>This is probably one of the crucial differences between VMware ESXi, and vSphere. vSphere, the paid version, has an API, and therefore can be automated. ESXi, doesn’t.</p>
<p>For proxmox, there are two terraform providers. <a href="https://registry.terraform.io/providers/Telmate/proxmox/latest/docs">one of them</a> is pretty barebones, you can create a cloud-init disk, an lxc container, or a virtual machine, and that’s it. A common complaint of proxmox is that automation featuers are lacking, and in this example, you cannot create networks.</p>
<p>There is another Terraform provider however, which <a href="https://registry.terraform.io/providers/bpg/proxmox/latest/docs/resources/virtual_environment_network_linux_bridge">seems to be able to create networks</a>, but both seem to be missing the ability to manage clustering.</p>
<p>Proxmox also has a <a href="https://www.pulumi.com/registry/packages/proxmoxve/api-docs/network/">pulumi provider</a>, but that is lacking as well, unable to create virtual networks at all, only configure Proxmox’s firewall.</p>
<p>An interesting coincidence, I recently came across <a href="https://programming.dev/post/10169968">a Lemmy post discussing this</a>, where <a href="https://programming.dev/comment/7478899">one user</a> mentions that they attempted to wrtie their own terraform provider, but eventually gave up. <a href="https://programming.dev/comment/7478238">Another user</a> talks about having to use ssh to finish up what the Terraform is unable to do, passing an iGPU through to a container.</p>
<p>Compared this to the <a href="https://registry.terraform.io/providers/lxc/incus/latest/docs/resources">terraform provider for lxd/incus</a>, where, in addition to vms/lxc containers, you can configure virtual networks, volumes, snapshots, even load balancing… but no clustering.</p>
<p>On the even more exteme end, <a href="https://registry.terraform.io/providers/terraform-provider-openstack/openstack/latest/docs">the terraform provider for openstack</a> lets you configure nearly every component of openstack, from VM’s, to networks, to load balancing. It even lets you spin up databases as a service (<a href="https://www.reddit.com/r/openstack/comments/1aluqnz/does_anyone_use_trove_module_to_provide_dbaas/">although people say that those are more trouble than they are worth to get running</a>).</p>
</section>
</section>
<section id="performance" class="level1">
<h1>Performance</h1>
<p>What’s performance like?</p>
<p>Here are some relevant performance articles</p>
<p>LXC vs Hypervisors: <a href="https://link.springer.com/chapter/10.1007/978-3-030-74402-1_12" class="uri">https://link.springer.com/chapter/10.1007/978-3-030-74402-1_12</a></p>
<p>Xen vs KVM and overheads: <a href="https://sites.cc.gatech.edu/systems/projects/Elba/pub/JackLiBigdata13.pdf" class="uri">https://sites.cc.gatech.edu/systems/projects/Elba/pub/JackLiBigdata13.pdf</a></p>
<p>Performance of several platforms: <a href="https://link.springer.com/chapter/10.1007/978-3-319-91186-1_16" class="uri">https://link.springer.com/chapter/10.1007/978-3-319-91186-1_16</a></p>
<p>Comparision of desktop hypervisors: <a href="https://link.springer.com/chapter/10.1007/978-3-030-74402-1_12" class="uri">https://link.springer.com/chapter/10.1007/978-3-030-74402-1_12</a></p>
<p>Four hypervisor comparison: <a href="https://ieeexplore.ieee.org/abstract/document/6572995" class="uri">https://ieeexplore.ieee.org/abstract/document/6572995</a></p>
<p>Docker vs Native vs Xen: <a href="https://ieeexplore.ieee.org/abstract/document/8248375" class="uri">https://ieeexplore.ieee.org/abstract/document/8248375</a></p>
<p>Hypervisors vs Lightweight virtualization: <a href="https://ieeexplore.ieee.org/abstract/document/7092949" class="uri">https://ieeexplore.ieee.org/abstract/document/7092949</a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/moonpiedumplings\.github\.io");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>